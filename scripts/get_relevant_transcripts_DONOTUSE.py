# THIS IS AN OLD VERSION - USE get_representative_transcripts.py

from gtfparse import read_gtf
import gzip
import csv
import random
import requests
import json

# Ensembl gene trees are generated by the Gene Orthology/Paralogy prediction method pipeline. 
# All homologues in Ensembl are determined from gene trees.

# Gene trees are constructed using one representative protein for every gene in every species in Ensembl.  
# The longest translation annotated by the CCDS project is used, if any are available, 
# or the longest protein-coding translation otherwise.  (The trees can also be considered as protein trees).

# In order to extract the (human) protein ids thata are used for the ensemble orthologs data,
# we open Biomart (https://m.ensembl.org/biomart/martview)
# Filters: 
# Transcript type: protein_coding
#
# Attributes:
# Gene stable ID
# Transcript stable ID
# CCDS ID
# Transcript length (including UTRs and CDS)
# Transcript type
# Protein stable ID

# The first line has to be deleted
# The representative protein is chosen according to the above description

# The orthologs data can be checked here:
# https://rest.ensembl.org/homology/id/ENSG00000226892?type=orthologues&content-type=application/json&cigar_line=0&sequence=none

# IMPORTANT
# It seems that genes without CCDS ID do not have any orthologs data, we omit these for now



# Input/Output file names (need to be in same folder)
rep_prot = 'representative_proteins_ensembl.txt'

output_file = 'relevant_transcripts.txt'




# Read known canonicals
with open(rep_prot, 'r') as opf:
    kc = opf.readlines()

ensembl_data = {}

for i in kc:
    i_s = i.split('\t')
    gene_id = i_s[0]
    transcript_id = i_s[1]
    has_ccds_id = 1 if len(i_s[2])>0 else 0
    transcript_length = int(i_s[3])
    protein_id = i_s[5].split('\n')[0]

    if has_ccds_id == 0:
        continue

    arr = [transcript_id, has_ccds_id, transcript_length, protein_id]

    if not gene_id in ensembl_data:
        ensembl_data[gene_id] = []
        ensembl_data[gene_id].append(arr)
    else:
        ensembl_data[gene_id].append(arr)




#print(ensembl_data)

# processed_genes = []
relevant_transcripts = []

for key in ensembl_data:
    ed = ensembl_data[key]
    ed_sorted = sorted(ed, key = lambda x: (-x[1], -x[2]))
    #print(ed_sorted)
    relevant_transcripts.append(ed_sorted[0][0])



#print(relevant_transcripts)

with open(output_file, 'w') as filehandle:
    json.dump(relevant_transcripts, filehandle)